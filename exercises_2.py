# -*- coding: utf-8 -*-

# 2.1 Допустим, вы строите приложение для управления финансами.
# 1. ПРОДУКТЫ
# 2. КИНО
# 3. ВЕЛОСИПЕДНЫЙ КЛУБ
# Ежедневно вы записываете все свои траты. В конце месяца вы анализируете
# расходы и вычисляете, сколько денег было потрачено. При
# работе с данными выполняется множество операций вставки и относительно
# немного операций чтения. Какую структуру использовать -
# массив или список?

# ответ
# список, ибо O(1) при добавлении.


# 2.2 Допустим, вы пишете приложение для приема заказов от посетителей
# ресторана. Приложение должно хранить список заказов. Официанты
# добавляют заказы в список, а повара читают заказы из списка и выполняют
# их. Заказы образуют очередь: официанты добавляют заказы
# в конец очереди, а повар берет первый заказ из очереди и начинает
# готовить.
# Какую структуру данных вы бы использовали для реализации этой
# очереди: массив или связанный список? (Подсказка: связанные списки
# хорошо подходят для вставки/удаления, а массивы - для произвольного
# доступа к элементам. Что из этого понадобится в данном случае?)

# ответ
# список лучше всех: O(1) на вставку, O(1) на удаление. Ну и резиновый

# 2.3 Проведем мысленный эксперимент. Допустим, Facebook хранит
# список имен пользователей. Когда кто-то пытается зайти на сайт
# Facebook, система пытается найти имя пользователя. Если имя входит
# в список имен зарегистрированных пользователей, то вход разрешается.
# Пользователи приходят на Facebook достаточно часто, поэтому
# поиск по списку имен пользователей будет выполняться часто. Будем
# считать, что Facebook использует бинарный поиск для поиска в списке.
# Бинарному поиску необходим произвольный доступ - алгоритм
# должен мгновенно обратиться к среднему элементу текущей части
# списка. Зная это обстоятельство, как бы вы реализовали список пользователей:
# в виде массива или в виде связанного списка?

# ответ
# связанный список очевидно же - wrong (отсортированный массив)

# 2.4 Пользователи также довольно часто создают новые учетные записи на
# Facebook. Предположим, вы решили использовать массив для хранения
# списка пользователей. Какими недостатками обладает массив для
# выполнения вставки? Допустим, вы используете бинарный поиск для
# нахождения учетных данных. Что произойдет при добавлении новых
# пользователей в массив?

# ответ
# массив ограничен по размеру. памяти может не хватить на всех пользователей
# wrong (вставка в массив выполняется медленно, сортировать массив при вставке нового имени)

# 2.5 В действительности Facebook не использует ни массив, ни связанный
# список для хранения информации о пользователях. Рассмотрим гибридную
# структуру данных: массив связанных списков. Имеется массив
# из 26 элементов. Каждый элемент содержит ссылку на связанный
# список. Например, первый элемент массива указывает на связанный
# список всех имен пользователей, начинающихся на букву «А». Второй
# элемент указывает на связанный список всех имен пользователей, начинающихся
# на букву «В», и т. д.

# Предположим, пользователь с именем :Adit в~ регистрируется на
# Facebook и вы хотите добавить его в список. Вы обращаетесь к элементу
# 1 массива, находите связанный список элемента 1 и добавляете
# «Adit в~ в конец списка. Теперь предположим, что зарегистрировать
# нужно пользователя 4:Zakhir н~. Вы обращаетесь к элементу 26, ко торый
# содержит связанный список всех имен, начинающихся с «Z~,
# и проверяете, присутствует ли 4:Zakhir н~ в этом списке.
# Теперь сравните эту гибридную структуру данных с массивами и связанными
# списками. Будет ли она быстрее или медленнее каждой исходной
# структуры при поиске и вставке? Приводить 0-большое не
# нужно, просто выберите одно из двух: быстрее или медленнее.

# сложно сказать, при поиске надо сортировать каждый раз при поиске.
# с другой стороны можно сортировать при вставке, и не сортировать при поиске
# быстрее - 50/50 (поиск медленнее - вставка быстрее)