# -*- coding: utf-8 -*-

# 4.1 Напишите код для функции sum (см. выше).

# ответ
def _sum(arr):
    return arr.pop(0) + _sum(arr) if len(arr) > 0 else 0

print _sum([1, 2, 3, 10]) # => 16

# 4.2 Напишите рекурсивную функцию для подсчета
# элементов в списке.

# ответ
def count_len(arr):
    return 1 + count_len(arr[1:]) if len(arr) > 0 else 0

print count_len([1, 2, 3, 10, 1, 'b', 'c', None]) # => 8


# 4.3 Найдите наибольшее число в списке.

# ответ
def get_max(arr, _max=0):
    current = arr.pop(0)
    _max = _max if current < _max else current
    return get_max(arr, _max) if arr else _max

# адаптированный вариант из книги

def book_get_max(arr):
    if len(arr) == 2:
        return arr[0] if arr[0] > arr[1] else arr[1]
    _max = book_get_max(arr[1:])
    return arr[0] if arr[0] > _max else _max


print get_max([1, 2, 20, 6, 2, 3, 10, 4, 16]) # => 20
print book_get_max([1, 2, 20, 6, 2, 3, 10, 4, 16]) # => 20

# 4.4 Помните бинарный поиск из главы 1? Он тоже
# относится к классу алгоритмов •разделяй и властвуй•. Сможете ли вы
# определить базовый и рекурсивный случай для бинарного поиска?

# ответ
# базовый случай бинарного поиска - это длина массива или списка равная одному
# рекурсивный - это пока у нас длина массива больше одного


# 4.5 Вывод значения каждого элемента массива.

# ответ
# O(n) - по количеству элементов


#4.6 Удвоение значения каждого элемента массива.

# ответ
# O(n) - по количеству элементов

# 4. 7 Удвоение значения только первого элемента массива.

# ответ
# O(1) - первый так первый

# 4.8 Создание таблицы умножения для всех элементов массива. Например,
# если массив состоит из элементов [2, 3, 7, 8, 10], сначала каждый элемент
# умножается на 2, затем каждый элемент умножается на 3, затем
# на 7 и т. д.

# ответ
# O(n * n)
